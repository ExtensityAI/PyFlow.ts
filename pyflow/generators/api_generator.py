"""
API generator for PyFlow.ts.
"""
from pathlib import Path

from ..core import registry

class ApiGenerator:
    """Generate FastAPI endpoints for PyFlow.ts-decorated objects."""

    def __init__(self, output_dir: Path, host: str = "localhost", port: int = 8000, reload: bool = False, debug: bool = False):
        self.host = host
        self.port = port
        self.reload = reload
        self.debug = debug
        self.output_dir = output_dir

    def generate_api_endpoints(self) -> str:
        """Generate FastAPI endpoints for all registered functions and methods."""
        api_code = '''# Generated by PyFlow.ts - DO NOT EDIT
import inspect
import importlib
import uuid
import json

from typing import Any, Dict, List, Optional, Union, Type
from fastapi import FastAPI, HTTPException, Body, Request
from pydantic import BaseModel, create_model
from pyflow.core import registry

# Instance cache to store object instances
instance_cache = {}

# Dynamic model generation for function args
def create_request_model(func_name: str, params: Dict[str, Any]) -> Type[BaseModel]:
    """Create a Pydantic model for function parameters."""
    fields = {}
    for name, param in params.items():
        if name == 'self':
            continue

        if param.default is inspect.Parameter.empty:
            # Required parameter
            fields[name] = (param.annotation, ...)
        else:
            # Optional parameter with default
            fields[name] = (param.annotation, param.default)

    return create_model(f"{func_name}Request", **fields)

# Initialize API router
app = FastAPI(title="Extensity API", description="Generated API for PyFlow.ts-decorated objects")

@app.post("/api/call-function")
async def call_function(request: Dict[str, Any] = Body(...)):
    """Call a Python function."""
    module_name = request.get("module")
    function_name = request.get("function")
    args = request.get("args", {})

    if not module_name or not function_name:
        raise HTTPException(status_code=400, detail="Module and function names are required")

    try:
        # Import the module
        module = importlib.import_module(module_name)

        # Get the function
        func = getattr(module, function_name.split('.')[-1], None)
        if not func or not callable(func):
            raise HTTPException(status_code=404, detail=f"Function {function_name} not found in module {module_name}")

        # Call the function with the arguments
        result = func(**args)

        # Return the result
        return {"result": result}

    except ImportError:
        raise HTTPException(status_code=404, detail=f"Module {module_name} not found")
    except (TypeError, ValueError) as e:
        raise HTTPException(status_code=400, detail=f"Invalid arguments: {str(e)}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error calling function: {str(e)}")

@app.post("/api/create-instance")
async def create_instance(request: Dict[str, Any] = Body(...)):
    """Create a new class instance and return its ID."""
    class_name = request.get("class")
    module_name = request.get("module", "")  # Get optional module name
    constructor_args = request.get("constructor_args", {})

    # Detailed debug logging for request data
    print(f"==== CREATE INSTANCE REQUEST ====")
    print(f"Raw request: {request}")
    print(f"Class name: {class_name}")
    print(f"Module name: {module_name}")
    print(f"Constructor args: {json.dumps(constructor_args, default=str, indent=2)}")

    # Check for common issues in constructor_args
    if constructor_args:
        for key, value in constructor_args.items():
            if key == '_module':
                print(f"Module from constructor_args: {value}")
            if value is None:
                print(f"Warning: Parameter {key} is None")
            elif isinstance(value, dict) and not value:
                print(f"Warning: Parameter {key} is an empty dict")

    if not class_name:
        raise HTTPException(status_code=400, detail="Class name is required")

    try:
        # Find class using existing methods
        print(f"Creating new instance of class: {class_name}")
        if module_name:
            print(f"From module: {module_name}")

        # Find the class (using multiple lookup strategies)
        cls = None
        available_classes = []

        # Show registry contents for debugging
        print(f"Registry contains {len(registry.classes)} classes:")
        for reg_name, reg_info in registry.classes.items():
            reg_module = reg_info.get('module', '')
            print(f"  - {reg_name} (module: {reg_module})")
            available_classes.append(f"{reg_name} (module: {reg_module})")

        # Strategy 1: Look by full name (module.ClassName)
        if module_name:
            full_name = f"{module_name}.{class_name}"
            print(f"Trying to find class by full name: {full_name}")
            if (full_name in registry.classes):
                cls = registry.classes[full_name]["cls"]
                print(f"✅ Found class by full name: {full_name}")

        # Strategy 2: Look by short name in all registered classes
        if not cls:
            print(f"Trying to find class by short name: {class_name}")
            for registered_name, class_info in registry.classes.items():
                short_name = registered_name.split('.')[-1]
                if short_name == class_name:
                    cls = class_info["cls"]
                    print(f"✅ Found class by short name: {class_name} (full: {registered_name})")
                    break

        # Strategy 3: If module name is provided, try finding classes with matching module
        if not cls and module_name:
            print(f"Trying to find class by module and name: {module_name}.{class_name}")
            for registered_name, class_info in registry.classes.items():
                registered_module = class_info.get('module', '')
                if module_name == registered_module and registered_name.endswith(f".{class_name}"):
                    cls = class_info["cls"]
                    print(f"✅ Found class by module and name: {registered_name}")
                    break

        # Final attempt - try a direct lookup by class name
        if not cls and class_name in registry.classes:
            print(f"Trying direct registry lookup: {class_name}")
            cls = registry.classes[class_name]["cls"]
            print(f"✅ Found class by direct registry lookup: {class_name}")

        if not cls:
            # Detailed error message with available classes
            error_msg = f"Class '{class_name}' not found in registry. Available classes: {', '.join(available_classes)}"
            print(f"❌ Error: {error_msg}")
            raise HTTPException(status_code=404, detail=error_msg)

        # Create instance with constructor args
        instance = None
        try:
            print(f"Creating instance of {cls.__name__} with args: {constructor_args}")
            if constructor_args:
                # Filter out '_module' which is a special parameter for our system
                filtered_args = {k: v for k, v in constructor_args.items() if k != '_module'}
                instance = cls(**filtered_args)
            else:
                instance = cls()

        except TypeError as e:
            error_msg = str(e)
            print(f"❌ TypeError during instance creation: {error_msg}")
            # Special handling for classes that might need specific args
            if "missing 1 required positional argument:" in error_msg:
                missing_arg = error_msg.split("missing 1 required positional argument: '")[1].split("'")[0]
                print(f"Missing required argument: {missing_arg}")
                if missing_arg in constructor_args:
                    print(f"Trying to create with just the required argument: {missing_arg}")
                    # Try to create with just the required argument
                    instance = cls(**{missing_arg: constructor_args[missing_arg]})
                    print(f"✅ Instance created successfully with {missing_arg}")
                else:
                    error_detail = f"Missing required constructor argument: {missing_arg}. Provided args: {list(constructor_args.keys())}"
                    print(f"❌ {error_detail}")
                    raise HTTPException(status_code=400, detail=error_detail)
            else:
                print(f"❌ Invalid constructor args: {str(e)}")
                raise HTTPException(status_code=400, detail=f"Invalid constructor args: {str(e)}")

        # Generate unique ID and store instance in cache
        instance_id = str(uuid.uuid4())
        instance_cache[instance_id] = {
            'instance': instance,
            'class_name': class_name
        }

        print(f"✅ Created instance with ID: {instance_id}")
        # Return the instance ID and info
        return {
            "instance_id": instance_id,
            "class_name": class_name
        }

    except HTTPException:
        # Re-raise HTTP exceptions as-is
        raise
    except Exception as e:
        import traceback
        print(f"❌ Error creating instance: {str(e)}")
        print(traceback.format_exc())
        raise HTTPException(status_code=500, detail=f"Error creating instance: {str(e)}")

@app.post("/api/call-method")
async def call_method(request: Dict[str, Any] = Body(...)):
    """Call a method on a Python class instance."""
    instance_id = request.get("instance_id")
    method_name = request.get("method")
    args = request.get("args", {})
    constructor_args = request.get("constructor_args", {})
    class_name = request.get("class")

    if not instance_id:
        # Legacy mode - create a new instance for this call
        print("Warning: No instance ID provided, creating temporary instance")
        if not class_name:
            raise HTTPException(status_code=400, detail="Either instance_id or class name is required")

        # Create a temporary instance - similar logic from create_instance
        # ...existing class-finding and instance creation code...

    else:
        # Get instance from cache
        print(f"Using cached instance with ID: {instance_id}")
        if instance_id not in instance_cache:
            raise HTTPException(status_code=404, detail=f"No instance found with ID {instance_id}")

        instance_data = instance_cache[instance_id]
        instance = instance_data['instance']
        class_name = instance_data['class_name']

    # Get and call the method - just like before
    if not method_name:
        raise HTTPException(status_code=400, detail="Method name is required")

    try:
        method = getattr(instance, method_name, None)
        if not method or not callable(method):
            raise HTTPException(status_code=404, detail=f"Method {method_name} not found in class {class_name}")

        print(f"Calling method {method_name} with args: {args}")
        result = method(**args)
        return {"result": result}

    except Exception as e:
        import traceback
        print(f"Exception in call_method: {str(e)}")
        print(traceback.format_exc())
        raise HTTPException(status_code=500, detail=f"Error calling method: {str(e)}")

# Register all PyFlow.ts-decorated functions as endpoints
'''

        # Generate explicit endpoints for each registered function
        for func_name, func_info in registry.functions.items():
            func = func_info['func']
            signature = func_info['signature']
            module_name = func_info['module']

            api_code += f'''
@app.post("/api/functions/{module_name.replace('.', '/')}/{func.__name__}")
async def _{func.__name__}_endpoint(request: Dict[str, Any] = Body(...)):
    """Call {func_name}."""
    try:
        # Import the module
        module = importlib.import_module("{module_name}")

        # Get the function
        func = getattr(module, "{func.__name__}")

        # Call the function with the arguments
        result = func(**request)

        # Return the result
        return {{"result": result}}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error calling function: {{str(e)}}")
'''

        # Generate explicit endpoints for each registered class method
        for class_name, class_info in registry.classes.items():
            cls = class_info['cls']
            module_name = class_info['module']

            for method_name, method_info in class_info['methods'].items():
                if method_name == '__init__':
                    continue

                api_code += f'''
@app.post("/api/methods/{module_name.replace('.', '/')}/{cls.__name__}/{method_name}")
async def _{cls.__name__}_{method_name}_endpoint(request: Dict[str, Any] = Body(...)):
    """Call {class_name}.{method_name}."""
    try:
        # Import the module
        module = importlib.import_module("{module_name}")

        # Get the class
        cls = getattr(module, "{cls.__name__}")

        # Create an instance
        instance = cls()

        # Call the method with the arguments
        result = instance.{method_name}(**request)

        # Return the result
        return {{"result": result}}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error calling method: {{str(e)}}")
'''

        return api_code

    def generate_server_app(self) -> str:
        """Generate the server app code that imports API and provides entry point."""
        server_code = f'''# Generated by PyFlow.ts - DO NOT EDIT
import importlib
import sys
from typing import List, Optional
import os
from pathlib import Path

import uvicorn

# Add this directory to path to allow direct execution
current_dir = Path(__file__).parent
sys.path.append(str(current_dir))

# Import the API app
from api import app

def port_in_use(host: str, port: int) -> bool:
    \"\"\"Check if a port is in use.\"\"\"
    import socket
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        return s.connect_ex((host, port)) == 0

def start_server(host: str = "{self.host}", port: int = {self.port}, reload: bool = {self.reload}, debug: bool = {self.debug}) -> None:
    \"\"\"Start the API server.\"\"\"
    if debug:
        print(f"Starting server in debug mode on {{host}}:{{port}}")

    # Try to find an available port if the specified one is in use
    if port_in_use(host, port):
        print(f"Warning: Port {{port}} is already in use.")
        for attempt in range(10):  # Try 10 ports starting from the specified one
            new_port = port + attempt + 1
            if not port_in_use(host, new_port):
                print(f"Using alternative port {{new_port}} instead.")
                port = new_port
                break
        else:
            print("Error: Could not find an available port. Please specify a different port using --port.")
            sys.exit(1)

    # Start the uvicorn server with the imported app
    uvicorn.run(
        app,
        host=host,
        port=port,
        reload=reload,
    )

if __name__ == "__main__":
    # Allow command-line parameters when run directly
    import argparse
    parser = argparse.ArgumentParser(description="Start the PyFlow.ts API server")
    parser.add_argument("--host", default="{self.host}", help="Host to bind to")
    parser.add_argument("--port", type=int, default={self.port}, help="Port to bind to")
    parser.add_argument("--reload", action="store_true", help="Enable auto-reload")
    parser.add_argument("--debug", action="store_true", help="Enable debug mode")
    args = parser.parse_args()

    start_server(args.host, args.port, args.reload, args.debug)
'''
        return server_code

    def generate_api(self) -> None:
        """Generate the FastAPI application."""
        # Create the output directory if it doesn't exist
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Generate and write the API endpoints
        api_code = self.generate_api_endpoints()
        api_file = self.output_dir / "api.py"
        with open(api_file, 'w') as f:
            f.write(api_code)

        # Generate and write the server app
        server_code = self.generate_server_app()
        server_file = self.output_dir / "server.py"
        with open(server_file, 'w') as f:
            f.write(server_code)

        print(f"Generated FastAPI application at {api_file}")
        print(f"Generated server runner at {server_file}")

        # Create an __init__.py to make it a proper package
        init_file = self.output_dir / "__init__.py"
        with open(init_file, 'w') as f:
            f.write("# Generated by PyFlow.ts\n")

        # Create a main entry point for easier execution
        main_file = self.output_dir / "main.py"
        with open(main_file, 'w') as f:
            f.write("""# Generated by PyFlow.ts - DO NOT EDIT
from .server import start_server

if __name__ == "__main__":
    start_server()
""")
